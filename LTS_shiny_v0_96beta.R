packages <- c("shiny", 
              "rhandsontable", #required for reactive data input
              "tidyr",
              "lme4", # required for linear mixed effect models
              "car", # required for Shaphiro-Wilk test
              "ggplot2",
              "dplyr",
              "ggpmisc", # ggplot2 extension for calculating statistics (p-value)
              "broom") # required to print p-value on trend graphs

# Function to check and install packages
install_if_missing <- function(packages) {
  for (pkg in packages) {
    if (!require(pkg, character.only = TRUE)) {
      install.packages(pkg)
      library(pkg, character.only = TRUE)
    }
  }
}

# Install missing packages
install_if_missing(packages)

ui <- shinyUI(fluidPage(
  titlePanel("CRM stability and homogeneity assessment"),
  h5("Estimation of uncertainty associated with stability and homogeneity based on the restricted maximum likelihood (REML) method using linear mixed effect models"),
  
  tabsetPanel(
    tabPanel("Data input", 
             sidebarLayout(
               sidebarPanel(
                 helpText(h3("Define your study below and fill in the tables with your data.")),
                 br(),
                 
                 #numericInput(inputId = "time_points", label = "Number of Time Points:", value = 4, min = 1, width = '50%'),
                 
                 #uiOutput("num_run_input"),
                 
                 div(style = "white-space: nowrap;", 
                     numericInput(inputId = "time_points", label = "Number of Time Points (per study):", value = 4, min = 1, width = '30%')),
                 
                 div(style = "white-space: nowrap;", 
                     numericInput(inputId = "no_units", label = "Number of units per time point:", value = 2, min = 1, width = '30%')),
                 
                 div(style = "white-space: nowrap;", 
                     numericInput(inputId = "no_repl", label = "(Maximum) number of replicates:", value = 5, min = 2, width = '30%')),
                 br(),
                 actionButton("Example", "Example dataset", class = "btn-block"),
               width = 2),
               mainPanel(
                 helpText(h3("Table of measured values")),
                 helpText(h5("Fill in the table with time point, unit number, and measurement results data!")),
                 rHandsontableOutput("hot"),
                 
                 br(),
                 
                 helpText(h3("Table of analytical sequence")),
                 helpText(h5("(Optional) Fill in the table with the corresponding analytical sequence values!")),
                 span(textOutput("data_warn1"), style="color:red"),
                 rHandsontableOutput("hot2"),
                 
                 br(),
                 
                 helpText(h3("Table of measurement runs")),
                 helpText(h5("(Optional) Fill in the table with the correspondin measurement run numbers!")),
                 span(textOutput("data_warn2"), style="color:red"),
                 rHandsontableOutput("hot3"),
                 br(),
                 downloadButton("report", "Generate report"),
                 br()
               )
             )
    ),
    tabPanel("Descriptive statistics",
             sidebarLayout(
               sidebarPanel(
                 uiOutput("checkboxGroup"),
                 width = 2),
               mainPanel(
                 fluidRow(
                   column(12, h4("Summary table"), tableOutput("summary_table"), align="center")),
                 br(),
                 fluidRow(
                   column(6, plotOutput("data_graph", width = "auto", height = 480)),
                   column(6, plotOutput("data_boxplot", width = "auto", height = 480))),
                 br(),
                 fluidRow(
                   column(6, plotOutput("anal_seq", width = "auto", height = 480)),
                   column(6, plotOutput("hist", width = "auto", height = 480)))
               )
             )
    ),
    tabPanel("Assumption checks",
             helpText(h3("Homoscedasticity check")), 
             verbatimTextOutput("lev_test"),
             br(),
             fluidRow(
               column(6, helpText("Residuals vs fitted values graph"),
               plotOutput("assOutput", width = "auto", height = 480),
               uiOutput("res_vs_fitplot"))  
             ),
             br(),
             helpText(h3("Normality check")),
             htmlOutput("sap_test"),
             br(),
             fluidRow(
               column(6, plotOutput("ass2Output", width = "auto", height = 480),
               uiOutput("QQplots"))
             ),
             br()
             
    ),
    tabPanel("Uncertainty associated with stability", 
             sidebarLayout(
               sidebarPanel(
                 helpText("Define your study below and fill in the table with your data."),
                 wellPanel(
                   div(style = "white-space: nowrap;", 
                       numericInput(inputId = "target_time_int", label = "Target time interval:", value = 12, min = 0, width = '30%')),
                   br(),
                   radioButtons("Unit", h3("Unit"), c("day(s)", "week(s)", "month(s)", "year(s)"), selected = "month(s)")
                 ),
                 width = 2),
               mainPanel(
                 tableOutput("ustab_table"), 
                 verbatimTextOutput("ustab"),
                 verbatimTextOutput("ucOutput"),
                 verbatimTextOutput("bias")
               )
             )
    ), 
    tabPanel("Uncertainty associated with heterogeneity", 
             sidebarLayout(
               sidebarPanel(
                 helpText("If replicate measurment of multiple units were used for the stability study then the uncertainty associated with heterogeneity can be also estimated."),
                 helpText(h5("Please, keep in mind: if the number of units is small (5-6 or less) then the estimate has a large uncertainty.")),
                 width = 2),
               mainPanel(
                 tableOutput("uhom_table"),
                 verbatimTextOutput("uhom"),
                 verbatimTextOutput("uc_homOutput")
               )
             )
    )
  )
))

server <- function(input, output, session) {
  
  values <- reactiveValues(df = NULL, df2 = NULL, df3 = NULL)
  
  observe({
    #if (is_loading_example()) {
      # Do nothing because we are in the process of loading the example
     # return()
    #}
    n <- as.integer(input$no_units)
    n2 <- as.integer(input$time_points)
    num_rows <- n * n2
    num_cols <- 2L + as.integer(input$no_repl)
    
    df <- data.frame(matrix(nrow = num_rows, ncol = num_cols))
    colnames(df) <- c("time", "unit_no", paste0("repl", 1L:as.integer(input$no_repl)))
    
    # Convert columns to character to allow text input
    # df[] <- lapply(df, function(x) format(as.numeric(x), scientific = TRUE, digits = 3))
    # df[] <- lapply(df, function (x) {as.numeric(sprintf("%.4g", x))} )
    df[] <- lapply(df, as.numeric)
    print("df first")
    print(str(df))
    
    values$df <- df
    
    # creating data frame for analytical sequence
    df2 <- data.frame(matrix(nrow = num_rows, ncol = num_cols))
    colnames(df2) <- colnames(df)
    
    # Convert columns to character to allow text input
    df2[] <- lapply(df2, as.numeric)
    
    values$df2 <- df2
    
    # creating data frame for measurment run
    df3 <- data.frame(matrix(nrow = num_rows, ncol = num_cols))
    colnames(df3) <- colnames(df)
    
    # Convert columns to character to allow text input
    df3[] <- lapply(df3, as.numeric)
    
    values$df3 <- df3
  })
  
  output$hot <- renderRHandsontable({
    req(input$no_units)
    df <- values$df
    df2 <- values$df2
    df3 <- values$df3
    values$df2$unit_no <- df$unit_no  # Update 'unit_no' in df2 with the values from df
    values$df2$time <- df$time  # Update 'time' in df2 with the values from df
    values$df3$time <- df$time  # Update 'time' in df3 with the values from df
    values$df3$unit_no <- df$unit_no  # Update 'unit_no' in df3 with the values from df
    #df_display <- lapply(df, function(x) format(as.numeric(x), scientific = TRUE, digits = 3))
    #df_display <- as.data.frame(df_display)
    #print(df_display)
    if (!is.null(df)) {
      rhandsontable(df, stretchH = "all", rowHeaders = NULL) %>%
        hot_table(
          highlightCol = TRUE,
          highlightRow = TRUE,
          contextMenu = TRUE,
          readOnly = FALSE  # Set readOnly to TRUE for "unit_no" column
        ) %>%
        hot_col(c("time", "unit_no"), format = "0") %>%
        hot_context_menu(allowRowEdit = FALSE, allowColEdit = FALSE) #%>%
      #hot_col(c(paste0("repl", 1:as.integer(input$no_repl))), format = "0.00e+0") 
    }
  })
  
  output$hot2 <- renderRHandsontable({
    req(input$no_units)
    df2 <- values$df2
    if (!is.null(df2)) {
      rhandsontable(df2, stretchH = "all", rowHeaders = NULL) %>%
        hot_table(
          highlightCol = TRUE,
          highlightRow = TRUE,
          contextMenu = TRUE
        ) %>%
        hot_col(c("time", "unit_no"), readOnly = TRUE, format = "0") %>%
        hot_col(c("time", "unit_no", paste0("repl", 1L:as.integer(input$no_repl))), format = "0") %>%
        hot_context_menu(allowRowEdit = FALSE, allowColEdit = FALSE) 
    }
  })
  
  output$hot3 <- renderRHandsontable({
    req(input$no_units)
    df3 <- values$df3
    if (!is.null(df3)) {
      rhandsontable(df3, stretchH = "all", rowHeaders = NULL) %>%
        hot_table(
          highlightCol = TRUE,
          highlightRow = TRUE,
          contextMenu = TRUE
        ) %>%
        hot_col(c("time", "unit_no"), readOnly = TRUE, format = "0") %>%
        hot_col(c("time", "unit_no", paste0("repl", 1:as.integer(input$no_repl))), format = "0") %>%
        hot_context_menu(allowRowEdit = FALSE, allowColEdit = FALSE) #%>%
    }
  })
  
  observeEvent(input$hot, {
    #req(input$no_units)
    df <- hot_to_r(input$hot)
    values$df <- df
    print("df updated")
    print(str(df))
  }, ignoreInit = TRUE)
  
  observeEvent(input$hot2, {
    #req(input$no_units)
    df2 <- hot_to_r(input$hot2)
    values$df2 <- df2
    print("df2 updated")
    print(str(df2))
  }, ignoreInit = TRUE)
  
  observeEvent(input$hot3, {
    #req(input$no_units)
    df3 <- hot_to_r(input$hot3)
    values$df3 <- df3
    print("df3 updated")
    print(str(df3))
  }, ignoreInit = TRUE)
  
  #is_loading_example <- reactiveVal(FALSE)
  # BUG! Example needs to clicked twice if wrong input values are set! 
  observeEvent(input$Example, {
    #is_loading_example(TRUE)
      # Update the numeric inputs
      updateNumericInput(session, "time_points", value = 4L) 
      updateNumericInput(session, "no_units", value = 2L)
      updateNumericInput(session, "no_repl", value = 5L)
      
      # Load the example datasets
    df <- read.csv("https://raw.githubusercontent.com/kamitoth/LTS/ca711a99857744ba86d1be176519020d989ed81c/df_example1.csv")
    df2 <- read.csv("https://raw.githubusercontent.com/kamitoth/LTS/ca711a99857744ba86d1be176519020d989ed81c/df_example2.csv")
    df3 <- read.csv("https://raw.githubusercontent.com/kamitoth/LTS/ca711a99857744ba86d1be176519020d989ed81c/df_example3.csv")
    # Convert columns to numeric
    df[, 3:7] <- sapply(df[, 3:7], as.numeric)
    
    #df3[, 3:7] <- sapply(df[, 3:7], as.character) # characters in run table should be allowed
    
    # Update the reactive values
    values$df <- df
    values$df2 <- df2
    values$df3 <- df3

  }, ignoreInit = TRUE)
  
  observe({
    req(values$df)
    # The Data Frame
    df <- values$df
    df2 <- values$df2
    df3 <- values$df3
    
    #Count how many 'repl' columns contain any value
    non_na_repl <- try(sum(colSums(!is.na(df[,-(1L:2L)])) > 0),F)
    # then take the larger of input$no_repl or actual data columns
    # gather() may not work if input$no_repl is the larger
    max_repl_col <- as.integer(max(req(as.integer(input$no_repl)), non_na_repl))
    print("max_repl_col")
    print(max_repl_col)
    req(max_repl_col !=0)
    
    # Convert df to long format
      df_long <- gather(df, rep, res, paste0("repl", 1L:max_repl_col))
      df_long <- df_long[colSums(!is.na(df_long)) > 0] # fool-proofing: delete columns with all NA values if exist
      
      #Check if df2 (analytical sequence df) can be combined with df_long
      if (!all(is.na(df2[,-(1L:2L)])) & identical(colSums(!is.na(df)), colSums(!is.na(df2)))) {
        #req(identical(colSums(!is.na(df)), colSums(!is.na(df2))))
        df2_long <- gather(df2, rep, anal, paste0("repl", 1L:max_repl_col))
        values$df2_long <- df2_long
        if (identical(which(is.na(df_long$res)), which(is.na(df2_long$anal)))) {
          df_long <- cbind(df_long, anal=df2_long$anal)
        }
      }
      
      #Check if df3 (measuerment run df) can be combined with df_long
      if (!all(is.na(df3[,-(1L:2L)])) & identical(colSums(!is.na(df)), colSums(!is.na(df3)))) {
        #req(identical(colSums(!is.na(df)), colSums(!is.na(df3))))
        df3_long <- gather(df3, rep, run, paste0("repl", 1L:max_repl_col))
        values$df3_long <- df3_long
        if (identical(which(is.na(df_long$res)), which(is.na(df3_long$run)))) {
          df_long <- cbind(df_long, run=df3_long$run)
        } 
      }
      
      values$df_long <- df_long
      #values$df_long$res <- as.numeric(values$df_long$res)
      
      # Check unique levels of time
      unique_time <- unique(na.omit(df_long$time)) 
      print("df_long created")
      print(str(df_long))
      print("unique_time")
      print(length(unique_time))
      
      # Check unique levels of unit_no
      unique_unit_no <- 1
      if (!is.null(df_long$unit_no)) {
        unique_unit_no <- unique(na.omit(df_long$unit_no))
      }

      print("unique_unit_no")
      print(length(unique_unit_no))
      
      #Check unique levels of run
      #unique_run <- 1
      if (!is.null(df_long$run)) {
        unique_run <- unique(na.omit(df_long$run))
        df_long$run <- as.factor(df_long$run) # maybe it should be defined as factor from the beginning to allow character input!
      }
      
      # THE ENGINE
      if(all(rowSums(!is.na(df[,-(1L:2L)])) > 1)){ #min. 2 replicates per time point is required #### MAYBE if is needed!
      # to make sure that previous analysis does not appear in ass, ustab, uhom
      print("rowsums")
      print(rowSums(!is.na(df[,-(1L:2L)])) > 1)
      #req(sum(!is.na(df_long$res)) > length(unique_time)*2L)
      # Change this to calculate u_hom
      # How? update formula would be good: update_formula()
      #update(uc, .~. -time)
      if (length(unique_time) < 2L) {
        values$uc <- "Error: Not enough unique levels in 'time' for regression analysis."
        # same unit tested under repeatability conditions without analytical trend check
      }
      req(length(unique_time) > 1L)
        # If only a single unit was tested and only the measurement data is provided
      if (length(unique_unit_no) < 2L && !("anal" %in% colnames(df_long)) & !("run" %in% colnames(df_long))) {
        uc <- lm(res ~ time, df_long)
        # same unit tested under repeatability conditions with analytical trend check
      }
      # If only a single unit was tested and measurement data and analytical sequence are provided
      else if (length(unique_unit_no) < 2L && "anal" %in% colnames(df_long) & !("run" %in% colnames(df_long))) {
        #check linear regression slope for significance
        anal_reg <- lm(res ~ anal, df_long)
        sig_slope <- round(coef(summary(anal_reg))[ 'anal', "Pr(>|t|)"], digits=2)
        #if significant: correct dataset?
        if (sig_slope < 0.05) {
          # correct data for analytical trend
          df_long$res2 <- df_long$res - df_long$anal * summary(lm(res ~ anal, df_long))$coefficients['anal', 'Estimate']
          uc <- lm(res2 ~ time, df_long) 
        } else {
          uc <- lm(res ~ time, df_long)
        }
      }
      # If only a single unit was tested and measurement and run data are provided
      else if (length(unique_unit_no) < 2L & !("anal" %in% colnames(df_long)) & "run" %in% colnames(df_long)) {
        # LME with run as random effect even though it might have few levels
        # Should it be lm vs LME based on the number of run levels???
        uc <- lmer(res ~ time + (1|run), df_long)
      }
      # If only a single unit was tested and measurement and run data and analytical sequence are all provided
      else if (length(unique_unit_no) < 2 & "anal" %in% colnames(df_long) & "run" %in% colnames(df_long)) {
        # use 'run' as fixed effect if it has less than 6 levels (frequent case)
        if (length(unique_run) < 6){
          anal_reg <- lm(res ~ time + run + run:anal, df_long)
          coef_summary <- coef(summary(anal_reg))
          rows_anal <- grep("anal", rownames(coef_summary), value = TRUE)
          sig_slope <- round(coef_summary[ rows_anal, "Pr(>|t|)"], digits=2)
          #sig_slope <- anova(lmerTest::lmer(res ~ time + run + run:anal + (1|run), df_long))['anal','Pr(>F)'] # to obtain approximate p-values
          print("sziggg_slope")
          print(sig_slope)
          if (any(sig_slope < 0.05)){
            uc <- lm(res ~ time + run + run:anal, df_long)
            # Otherwise use simpler model
          } else {
            uc <- lm(res ~ time + run, df_long)
            print("ucci")
            print(uc)
          }
        }
        # use 'run' as random effect if it has more than 6 levels 
        else {
          # Estimate significance level of the LME slope
          sig_slope <- anova(lmerTest::lmer(res ~ time + anal + (1|run), df_long))['anal','Pr(>F)'] # to obtain approximate p-values
          print("szigi_slope")
          print(sig_slope)
          if (sig_slope < 0.05){
            uc <- lmer(res ~ time + anal + (1|run), df_long)
            # Otherwise use simpler model
          } else {
            uc <- lmer(res ~ time + (1|run), df_long)
            print("ucci")
            print(uc)
          } 
        }
      }
      # if more then 1 units were tested
      else if (length(unique_unit_no) > 1L & !("anal" %in% colnames(df_long)) & !("run" %in% colnames(df_long))) {
        # Perform REML fit
        # unit_no is treated as random effect regardless of the number of levels
        # (ideally at least 8 units should be tested)
        uc <- lmer(res ~ time + (1|unit_no), df_long)
        print("eddig OK")
        print(str(uc))
      }
      else if (length(unique_unit_no) > 1L & !("anal" %in% colnames(df_long)) & ("run" %in% colnames(df_long))) {
        # Use nested model if design is fully nested
        M <- table(df_long$run, df_long$unit_no)
        if (all(colSums(M > 0L) == 1L)) {
          # use 'run' as fixed effect if it has less than 6 levels (frequent case)
          if (length(unique_run) < 6){
          uc <- lmer(res ~ time + run + (1|run:unit_no), df_long)
          } 
          # use 'run' as random effect if it has more than 6 levels 
          else{
            uc <- lmer(res ~ time + (1|run/unit_no), df_long)
          }
        } 
        # Use crossed model otherwise
        else {
          # use 'run' as fixed effect if it has less than 6 levels (frequent case)
          if (length(unique_run) < 6){
            uc <- lmer(res ~ time + run + (1|unit_no), df_long)
          } 
          # use 'run' as random effect if it has more than 6 levels 
          else{
          uc <- lmer(res ~ time + (1|run) + (1|unit_no), df_long)
        }
        # 'Run' is used as random effect regardless of the number of levels
        # Otherwise it could mess up the fixed effect and SE estimations
        }
      }
      else if (length(unique_unit_no) > 1L & ("anal" %in% colnames(df_long)) & !("run" %in% colnames(df_long))) {
        # Estimate significance level of the LME slope
        sig_slope <- anova(lmerTest::lmer(res ~ time + anal + (1|unit_no), df_long))['anal','Pr(>F)'] # to obtain approximate p-values
        # If significant, add analytical sequence to the model
        print("most mege ez")
        print(sig_slope)
        if (sig_slope < 0.05){
          uc <- lmer(res ~ time + anal + (1|unit_no), df_long)
        }
        # Otherwise use the simpler model
        else {
          uc <- lmer(res ~ time + (1|unit_no), df_long)
        }
        # For both 'anal' and 'run' present...
      }
      else if (length(unique_unit_no) > 1L & ("anal" %in% colnames(df_long)) 
               & ("run" %in% colnames(df_long))) {
        # Use nested model if design is fully nested
        M <- table(df_long$run, df_long$unit_no)
        if (all(colSums(M > 0L) == 1L)) {
          # use 'run' as fixed effect if it has less than 6 levels (frequent case)
          # Estimate significance level of the LME slope
          # Singular fit if or rank deficient model matrix for fully nested model!?
          if (length(unique_run) < 6){
            anal_reg <- lmerTest::lmer(res ~ time + run + run:anal + (1|run:unit_no), df_long)
            # using summary to perform separate tests for each level of the interaction
            coef_summary <- coef(summary(anal_reg))
            rows_anal <- grep("anal", rownames(coef_summary), value = TRUE)
            sig_slope <- round(coef_summary[ rows_anal, "Pr(>|t|)"], digits=2)
          #sig_slope <- anova(lmerTest::lmer(res ~ time + anal + (1|run/unit_no), df_long))['anal','Pr(>F)'] # to obtain approximate p-values
            # If significant, add analytical sequence to the model
            if (any(sig_slope < 0.05)){
              uc <- lmer(res ~ time + run + run:anal + (1|run:unit_no), df_long)
              # Otherwise use simpler model
            } else {
              uc <- lmer(res ~ time + run + (1|run:unit_no), df_long)
            }
          }
          # use 'run' as random effect if it has more than 6 levels
          else{
            anal_reg <- lmerTest::lmer(res ~ time + anal + (anal|run) + (1|run:unit_no), df_long)
            # using summary to perform separate tests for each level of the interaction
            coef_summary <- coef(summary(anal_reg))
            rows_anal <- grep("anal", rownames(coef_summary), value = TRUE)
            sig_slope <- round(coef_summary[ rows_anal, "Pr(>|t|)"], digits=2)
            # If significant, add analytical sequence to the model
            if (any(sig_slope < 0.05)){
              uc <- lmer(res ~ time + anal + (anal|run) + (1|run:unit_no), df_long)
              # Otherwise use simpler model
            } else {
              uc <- lmer(res ~ time + (1|run/unit_no), df_long)
            }
          }
        } else {
          # Use crossed model if design is not fully nested...
          # use 'run' as fixed effect if it has less than 6 levels (frequent case)
          if (length(unique_run) < 6){
            anal_reg <- lmerTest::lmer(res ~ time + run + run:anal + (1|unit_no), df_long)
            # using summary to perform separate tests for each level of the interaction
            coef_summary <- coef(summary(anal_reg))
            rows_anal <- grep("anal", rownames(coef_summary), value = TRUE)
            sig_slope <- round(coef_summary[ rows_anal, "Pr(>|t|)"], digits=2)
            #sig_slope <- anova(lmerTest::lmer(res ~ time + anal + (1|run/unit_no), df_long))['anal','Pr(>F)'] # to obtain approximate p-values
            # If significant, add analytical sequence to the model
            if (any(sig_slope < 0.05)){
              uc <- lmer(res ~ time + run + run:anal + (1|unit_no), df_long)
              # Otherwise use simpler model
            } else {
              uc <- lmer(res ~ time + run + (1|unit_no), df_long)
            }
          }
          # use 'run' as random effect if it has more than 6 levels
          else{
            anal_reg <- lmerTest::lmer(res ~ time + run + run:anal + (1|unit_no), df_long)
            # using summary to perform separate tests for each level of the interaction
            # THIS IS AN APPROXIMATE SOLUTION OF AN APPROXIMATION
            # CHANGE IT TO anova(), AIC or BIC!
            coef_summary <- coef(summary(anal_reg))
            rows_anal <- grep("anal", rownames(coef_summary), value = TRUE)
            sig_slope <- round(coef_summary[rows_anal, "Pr(>|t|)"], digits=2)
            print("sigggi slope")
            print(sig_slope)
            # If significant, add analytical sequence to the model
            if (any(sig_slope < 0.05)){
              uc <- lmer(res ~ time + (anal|run) + (1|unit_no), df_long)
              # Otherwise use simpler model
            } else {
              uc <- lmer(res ~ time + (1|run) + (1|unit_no), df_long)
            }
          }
        }
      }
        
        # Saphiro-Wilk test for checking normality
        # BUG is still there!
        #tryCatch( { sap <- shapiro.test(residuals(uc))$p.value }
        #          , warning = function(w) { sap <- "Hey, a warning" })
        
        # BUG is still there!
        if (!is.null(uc)){
          sap <- try(shapiro.test(residuals(uc))$p.value)
          if (inherits(sap, "try-error")) sap <- "error"
        }

        # Extract standard error of the LME slope and calculate (approximate) p-values
        if (class(uc) == "lmerMod") {
          se_lme <- round(coef(summary(uc))["time" , "Std. Error"], digits=2)
          sig_lme <- anova(lmerTest::lmer(formula(uc), df_long))['time','Pr(>F)'] # to obtain approximate p-values
        } else {
          se_lme <- summary(uc)$coefficients['time', 'Std. Error'] # could be merged with lmerMod...
          sig_lme <- coef(summary(lm(formula(uc), data=df_long)))[ 'time', "Pr(>|t|)"]
        }
        # Perform the 'standard' linear regression (OLS) (just for comparison)
        lm_mod <- lm(res ~ time, df_long)
        # Extract standard error of the 'standard' linear fit slope (just for comparison)
        se_lm <- summary(lm_mod)$coefficients['time', 'Std. Error']
        # 'standard' linear regression (OLS) on the unit means (again, just for comparison)
        if (length(unique_unit_no) > 1L) {
          df_long_mod <- df_long %>%
            group_by(unit_no) %>%
            summarise(res=mean(res, na.rm = TRUE), time=mean(time))
          lm_mod2 <- lm(res ~ time, df_long_mod)
          # If possible, extract standard error (again, just for comparison)
          if (nrow(summary(lm_mod2)$coefficients) > 1L) {
            se_lm2 <- summary(lm_mod2)$coefficients['time', 'Std. Error'] 
            values$se_lm2 <- se_lm2
          } else {
            values$se_lm2 <- print("Not calculable")
          }
        }

        values$uc <- uc
        values$sap <- sap
        values$se_lme <- se_lme
        values$se_lm <- se_lm
        values$sig_lme <- sig_lme
        values$u_stab <- ifelse(sig_lme<0.05, "significant slope", sprintf("%.2e",input$target_time_int*se_lme))
        values$u_stab_rel <- ifelse(sig_lme<0.05, "NA",input$target_time_int*se_lme/mean(df_long$res, na.rm = TRUE)*100)

        #Estimation of uncertainty associated with heterogeneity based on the stability data
        if (!is.null(uc) && inherits(uc, "lmerMod") && length(unique_unit_no) > 1L){
          uc_hom_VC <- as.data.frame(VarCorr(uc))
          between_unit_sd <- uc_hom_VC[grepl("unit_no", uc_hom_VC$grp),'sdcor']
          busd_rel <- between_unit_sd/mean(df_long$res, na.rm = TRUE)
          within_unit_sd <- uc_hom_VC[which(uc_hom_VC$grp == 'Residual'),'sdcor']
          wsd_rel <- within_unit_sd/mean(df_long$res, na.rm = TRUE)
          
          values$between_unit_sd <- between_unit_sd
          values$within_unit_sd <- within_unit_sd
          values$busd_rel <- busd_rel
          values$wsd_rel <- wsd_rel
        }
      }   else {
        values$uc <- "Insufficient data in measured values table." 
      }
  })
 
  output$data_graph <- renderPlot({
    df_long <- values$df_long
    df_long <- na.omit(df_long)
    print("itiitiitt")
    print(length(unique(df_long$unit_no)))
    print(str(df_long))
    if (!is.null(df_long) && length(unique(df_long$unit_no)) < 2L) {
      # If a 'single object' was tested 
      fit <- ggplot(df_long, aes(x=time, y=res))+
        geom_point(position=position_dodge2(0.5), size=3)+
        geom_smooth(method='lm', se = FALSE, color="black", formula = y ~ x)
    } else if (!is.null(df_long) && length(unique(df_long$unit_no)) > 1L){
      # Show unit numbers with different colors if multiple units were tested
      fit <- ggplot(df_long, aes(x=time, y=res, color=as.factor(unit_no)))+
        geom_point(position=position_dodge2(0.5), size=3)+
        geom_smooth(method='lm', se = FALSE, color="black", formula = y ~ x)+
        labs(colour = "unit number")
    }
    fit <- fit + labs(title = "Graph of the dataset", y="result")
    fit <- fit + theme(panel.border = element_rect(linetype = "solid", fill = NA),
                       plot.title = element_text(size = 22),
                       axis.title = element_text(size = 18),
                       axis.text = element_text(size = 15),
                       legend.title = element_text(size = 18),
                       legend.text = element_text(size = 15))
    if (!is.null(input$sel) && any(input$sel == "run")){
      fit <- fit + facet_wrap(~run)
    }
    print(fit)
  })
  
  output$data_boxplot <- renderPlot({
    df_long <- values$df_long
    df_long <- na.omit(df_long)
    if (!is.null(df_long) && length(unique(df_long$unit_no)) < 2L) {
      # If a 'single object' was tested 
      fit2 <- ggplot(df_long, aes(x=as.factor(time), y=res))+
        geom_boxplot(position=position_dodge2(0.5), outlier.size = 3)
    } else if (!is.null(df_long) && length(unique(df_long$unit_no)) > 1L){
      # Show unit numbers with different colors if multiple units were tested
      fit2 <- ggplot(df_long, aes(x=as.factor(time), y=res, color=as.factor(unit_no)))+
        geom_boxplot(position=position_dodge2(0.5), outlier.size = 3)+
        labs(colour = "unit number", x = "time")
    } else {
      print("Error")
    }
    fit2 <- fit2 + labs(title = "Boxplot representation of the dataset", y="result")
    fit2 <- fit2 + theme(panel.border = element_rect(linetype = "solid", fill = NA),
                       plot.title = element_text(size = 22),
                       axis.title = element_text(size = 18),
                       axis.text = element_text(size = 15),
                       legend.title = element_text(size = 18),
                       legend.text = element_text(size = 15))
    if (!is.null(input$sel) && any(input$sel == "run")){
      fit2 <- fit2 + facet_wrap(~run)
    }
    print(fit2)
  })
  
  output$anal_seq <- renderPlot({
    df_long <- values$df_long
    df_long <- na.omit(df_long)
    req(df_long$anal)
    if (!is.null(df_long) && length(unique(df_long$unit_no)) < 2L) {
      # If a 'single object' was tested 
      fit4 <- ggplot(df_long, aes(x=anal, y=res))+
        geom_point( size=3)+
        stat_smooth(method='lm', formula = y ~ x, se = FALSE, color="black")
    } else if (!is.null(df_long) && length(unique(df_long$unit_no)) > 1L){
      # Show unit numbers with different colors if multiple units were tested
      fit4 <- ggplot(df_long, aes(x=anal, y=res))+
        stat_smooth(method='lm', formula = y ~ x, se = FALSE, color="black")+
        geom_point( size=3)+
        labs(colour = "unit number")
    }
    fit4 <- fit4 + labs(title = "Analytical sequence graph", x="analytical sequence", y="result")
    fit4 <- fit4 + theme(panel.border = element_rect(linetype = "solid", fill = NA),
                       plot.title = element_text(size = 22),
                       axis.title = element_text(size = 18),
                       axis.text = element_text(size = 15),
                       legend.title = element_text(size = 18),
                       legend.text = element_text(size = 15))
    if (!is.null(df_long) && length(unique(df_long$run)) > 1L){
      fit4 <- fit4 + facet_wrap(~run)
    }
    fit4 <- fit4 + stat_fit_glance(method = "lm",
                                   label.y = "bottom",
                                   label.x = "right",
                                   method.args = list(formula = y ~ x),
                                   mapping = aes(label = sprintf('italic(p)~"="~%.2g', after_stat(p.value))),
                                   parse = TRUE)
    print(fit4)
  })
  
  # Update the checkboxGroupInput choices based on the data frame
 # output$checkboxGroup <- renderUI({
 #   df_long <- values$df_long
 #   if (!is.null(df_long)) {
 #     selected_columns <- colnames(df_long[,!colnames(df_long) %in% c("res", "rep", "anal", "time")])
 #     }
 #   print("selected columns")
 #   print(selected_columns)
 #   print("colnames")
 #   print(colnames(df_long))
 #   checkboxGroupInput("sel", "Group by", choices = selected_columns)
 # })
  
  output$checkboxGroup <- renderUI({
    df_long <- values$df_long
    selected_columns <- NULL  # Initialize selected_columns outside the if block
    
    if (!is.null(df_long)) {
      selected_columns <- setdiff(colnames(df_long),c("res", "time", "rep", "anal"))
    }

    checkboxGroupInput("sel", "Group by", choices = selected_columns)
  })
  
  # Could be added: number of replicates, runs, units...
  output$summary_table <- renderTable({
    df_long <- values$df_long
    if (!is.null(df_long)) {
      sum <- if (!is.null(input$sel)) {
        na.omit(df_long) %>%
          group_by(across(all_of(input$sel))) %>%
          summarise(
            mean = sprintf("%.2e", mean(res)),
            sd = sprintf("%.2e", sd(res)),
            median = sprintf("%.2e", median(res)),
            n = n()
            ) 
      } else {
        na.omit(df_long) %>%
            summarise(
              mean = sprintf("%.2e", mean(res)),
              sd = sprintf("%.2e", sd(res)),
              median = sprintf("%.2e", median(res)),
              n = n()
            ) 
      } 
    }
    if (!is.null(sum$unit_no)) {sum$unit_no <- as.character(sum$unit_no)}
    if (!is.null(sum$run)) {sum$run <- as.character(sum$run)}
    sum
  })
  
  output$hist <- renderPlot({
    df_long <- values$df_long
    df_long <- na.omit(df_long)
    if (!is.null(df_long)) {
      # If a 'single object' was tested 
      fit3 <- ggplot(df_long, aes(x=res))+
        geom_histogram(aes(y = after_stat(density)), colour = 1, fill = "white")+
        geom_density()
    } 
    fit3 <- fit3 + labs(title = "Histogram and kernel density of the dataset")
    fit3 <- fit3 + theme(panel.border = element_rect(linetype = "solid", fill = NA),
                         plot.title = element_text(size = 22),
                         axis.title = element_text(size = 18),
                         axis.text = element_text(size = 15),
                         legend.title = element_text(size = 18),
                         legend.text = element_text(size = 15))
    if (!is.null(input$sel) & length(input$sel) == 1){
        if (input$sel == "run") {
          fit3 <- fit3 + facet_wrap(~run)
        } else if (input$sel == "unit_no") {
          fit3 <- fit3 + facet_wrap(~unit_no)
        }
    } else if (!is.null(input$sel)){
      fit3 <- fit3 + facet_wrap(~ run + unit_no)
    }
    fit3 <- fit3 + labs(x ="result")
    print(fit3)
  })
  
  # summary of the lm or lmer fit 
  output$ucOutput <- renderPrint({
    uc <- values$uc
    #conv_status <- values$conv_status
    #df_long <- values$df_long
    if (!is.null(uc) & class(uc) == "lmerMod") {
      print(summary(uc))
      
      # Check singular fit warnings and print the warning message if present
      if (isSingular(uc)==TRUE){
        # Check convergence status and print the warning message if not converged
        conv_status <- summary(uc)$optinfo$conv$lme4$messages
        if (!is.null(conv_status)) {
          a <- warning("Warning!", conv_status)
        }
        b <- paste("The parameters are on the boundary of the feasible parameter space:", sep ="\n",
              "variances of one or more linear combinations of effects are (close to) zero")
        paste(a,b, sep ="\n")
      }
    } 
    # If only one 'unit' was used for the entire study summarise linear regression
    else if (!is.null(uc) & class(uc) == "lm"){
      print(summary(uc))
    }
    # Print the error message
    else{
      cat(warning(uc))
    }
  })
  
  output$data_warn1 <- renderText({
    df2 <- values$df2
    df <- values$df
    if (!all(is.na(df2[,-(1L:2L)])) & !identical(colSums(!is.na(df)), colSums(!is.na(df2)))) {
      paste("Number of data in analytical sequence table and measurement table do not match.",
            "Analytical sequence will be ignored!", sep="\n")
    } else if (!all(is.na(df2[,-(1:2)])) & identical(colSums(!is.na(df)), colSums(!is.na(df2))) &
               !identical(which(is.na(df)), which(is.na(df2)))) {
      paste("Position of data in analytical sequence table and measurement table do not match.",
            "Analytical sequence will be ignored!", sep="\n")
    }
  })
  
  output$data_warn2 <- renderText({
    df3 <- values$df3
    df <- values$df
    if (!all(is.na(df3[,-(1L:2L)])) & !identical(colSums(!is.na(df)), colSums(!is.na(df3)))) {
      paste("Number of data in run table and measurement table do not match.",
            ("Run data will be ignored!"), sep="\n")
    } else if (!all(is.na(df3[,-(1L:2L)])) & identical(colSums(!is.na(df)), colSums(!is.na(df3))) &
              !identical(which(is.na(df)), which(is.na(df3)))) {
      paste("Position of data in run table and measurement table do not match.",
            ("Run data will be ignored!"), sep="\n")
    }
  })
  
  output$assOutput <- renderPlot({
    uc <- values$uc
    print("mostmegitt")
    print(str(uc))
    print(uc)
    if (!is.null(uc) & class(uc) == "lmerMod") {
      # If uc is lmerMod, show residuals vs fitted values graph
      par(mfrow = c(2, 1)); plot(uc)
    } else if (!is.null(uc) & class(uc) == "lm") {
      # If uc is lm, show both residuals and standardized residuals vs fitted values graph
      par(mfrow = c(2, 1)); plot(uc, 1); plot(uc, 3)
    }
  })
  
  output$ass2Output <- renderPlot({
    uc <- values$uc
    if (!is.null(uc) & class(uc) == "lmerMod") {
      qqnorm(resid(uc)); qqline(resid(uc))
    } else if (!is.null(uc) & class(uc) == "lm") {
      plot(uc, 2)
    }
  })
  
  output$sap_test <- renderText({
    uc <- values$uc
    sap <- values$sap
    print("class")
    print(class(uc))
    if (class(uc) != "character" && !is.null(sap)) {
      paste(paste("Shapiro-Wilk's normality test p-value is", sep = " ", signif(sap, digits = 2), ".<br>"),
            if (sap > 0.05){
              "H0 (p>0.05): residuals are approximately normally distributed at the 95% CL."
            } else {
              "H0 (p<0.05): residuals are <span style='color:red;'> NOT </span> normally distributed at the 95% CL."
            }, sep="\n")
    }
  })
  
  url <- a("How to interpret QQ plots?", href="https://stats.stackexchange.com/questions/101274/how-to-interpret-a-qq-plot?noredirect=1&lq=1", target = "_blank")
  output$QQplots <- renderUI({
    url
  })
  
  url2 <- a("How to interpret residual vs fitted values plots?", href="https://stats.stackexchange.com/questions/76226/interpreting-the-residuals-vs-fitted-values-plot-for-verifying-the-assumptions", target = "_blank")
  output$res_vs_fitplot <- renderUI({
    url2
  })

  # u_stab summary table
  output$ustab_table <- renderTable({
    uc <- values$uc
    se_lme <- values$se_lme
    sig_lme <- values$sig_lme
    u_stab <- values$u_stab
    u_stab_rel <- values$u_stab_rel
    if (!is.null(uc) & class(uc) == "lmerMod") {
      ults <- data.frame(tcert=input$target_time_int,
                         slope= sprintf("%.2e", coef(summary(uc))[ , "Estimate"][[2L]]),
                         SE_slope= sprintf("%.2e", se_lme),
                         u_stab= u_stab,
                         u_stab_rel = u_stab_rel,
                         p = signif(sig_lme, digits=3),
                         Formula= deparse(formula(uc)))
      colnames(ults) = 
        c("t<sub>cert</sub>", "slope", "SE<sub>slope</sub>", "u<sub>stab</sub>", "u<sub>stab,rel</sub>%", "P", "Formula")
      return(ults)
      }
    }, sanitize.colnames.function = identity, caption = "Calculation of uncertainty associated with stability", caption.placement = "top")

  # u_stab summary text
  output$ustab <- renderText({
    uc <- values$uc
    se_lme <- values$se_lme
    sig_lme <- values$sig_lme
    u_stab <- values$u_stab
    u_stab_rel <- values$u_stab_rel
    print(sig_lme)
    if (!is.null(se_lme) && inherits(uc, "lmerMod")) {
      if (sig_lme < 0.05){
        paste(paste("Standard error of the slope based on the REML estimation of LME:", sep = " ", signif(se_lme, digits = 3)),
              paste("Uncertainty associated with stability is not provided because there is a significant trend in the stability study! See ISO Guide 35:2017 for guidance!"),
              sep="\n")
      } else {
        paste(paste("Standard error of the slope based on the REML estimation of LME:", sep = " ", signif(se_lme, digits = 3)),
              paste("The uncertainty associacetd with stability for", sep = " ", input$target_time_int, 
                    input$Unit, "=",
                    signif(input$target_time_int*se_lme, digits = 3)), 
              paste("If the mean accurately represents the central tendency of the dataset, then", signif(u_stab_rel, digits = 3), "% is the relative uncertainty associated with stability."),
              sep="\n")
      }
    } else if (!is.null(se_lme) && inherits(uc, "lm")){
      if (sig_lme < 0.05){
        paste(paste("Standard error of the slope of the linear regression:", sep = " ", signif(se_lme, digits = 3)),
              paste("Uncertainty associated with stability is not provided because there is a significant trend in the stability study! See ISO Guide 35:2017 for guidance!"), 
              sep="\n")
      } else {
        paste(paste("Standard error of the slope of the linear regression:", sep = " ", signif(se_lme, digits = 3)),
              paste("The uncertainty associacetd with stability for", sep = " ", input$target_time_int, 
                    input$Unit, "=",
                    signif(input$target_time_int*se_lme, digits = 3)),
              paste("If the mean accurately represents the central tendency of the dataset, then", signif(u_stab_rel, digits = 3), "% is the relative uncertainty associated with stability."),
              sep="\n")
      }
    }
  })
  
  # bias comparison with complete pooling and no pooling
  output$bias <- renderText({
    uc <- values$uc
    se_lme <- values$se_lme
    se_lm <- as.numeric(values$se_lm)
    se_lm2 <- as.numeric(values$se_lm2)
    val <- (se_lm-se_lme)/se_lme*100L
    val2 <- (se_lm2-se_lme)/se_lme*100L
    if (inherits(uc, "lmerMod") && !is.null(se_lm) & !is.null(se_lme)) {
      paste(paste("If between unit variances would be ignored (OLS - complete pooling)", sep="\n", "the uncertainty estimate would be biased by"), 
            paste(sep = " ", signif(val, digits = 3), "% and in case of no pooling by", signif(val2, digits = 3), "%."))
    }
  })
  
  # u_hom summary table
  uhom_table <- reactive({
    uc <- values$uc
    req(values$between_unit_sd)
    between_unit_sd <- values$between_unit_sd
    within_unit_sd <- values$within_unit_sd
    busd_rel <- values$busd_rel
    wsd_rel <- values$wsd_rel
    if (!is.null(uc) & inherits(uc, "lmerMod")) {
      uhomt <- data.frame(sbb= sprintf("%.2e", between_unit_sd),
                         sbb_rel= busd_rel*100,
                         swb= sprintf("%.2e", within_unit_sd),
                         swb_rel= wsd_rel*100,
                         Formula= deparse(formula(uc)))
      colnames(uhomt) = 
        c("s<sub>bb</sub>", "s<sub>bb,rel</sub>%", "s<sub>wb</sub>", "s<sub>wb,rel</sub>%", "Formula")
      return(uhomt)
    }
  })
  
  output$uhom_table <- renderTable({
    uhom_table()
  }, sanitize.colnames.function = identity, caption = "Calculation of values associated with heterogeneity", caption.placement = "top")
  
  # u_hom summary text
  output$uhom <- renderText({
    uc <- values$uc
    req(values$between_unit_sd)
    between_unit_sd <- values$between_unit_sd
    within_unit_sd <- values$within_unit_sd
    busd_rel <- values$busd_rel
    wsd_rel <- values$wsd_rel
    if (!is.null(uc) & inherits(uc, "lmerMod") && !is.null(between_unit_sd) & !is.null(within_unit_sd)) {
      paste(paste(paste("The between unit standard deviation (standard uncertainty associated with heterogeneity) estimate is", 
            signif(between_unit_sd, digits = 3), sep=" "),".", sep=""),
      paste("If the mean accurately represents the central tendency of the dataset, then", signif(busd_rel*100, digits = 3), "% is the relative between unit SD estimate."),
      paste(paste("At the same time, the within unit standard deviation (standard uncertainty associated with method repeatability) estimate is", 
            signif(within_unit_sd, digits = 3), sep=" "),".", sep=""),
      paste("If the mean accurately represents the central tendency of the dataset, then", signif(wsd_rel*100, digits = 3), "% is the relative within unit SD estimate."),
      sep="\n")
    } else {
      print("Dataset not suitable to perform REML.")
    }
  })
  
  # needed? same as for u_stab
  uc_homOutput <- reactive({
    uc <- values$uc
    if (!is.null(uc) & inherits(uc, "lmerMod")) {
      print(summary(uc))
      
      # Check singular fit warnings and print the warning message if present
      if (isSingular(uc)==TRUE){
        # Check convergence status and print the warning message if not converged
        conv_status <- summary(uc)$optinfo$conv$lme4$messages
        if (!is.null(conv_status)) {
          a <- warning("Warning!", conv_status)
        }
        b <- paste("The parameters are on the boundary of the feasible parameter space:", sep ="\n",
                   "variances of one or more linear combinations of effects are (close to) zero")
        paste(a,b, sep ="\n")
      }
    }
  })
  
  output$uc_homOutput <- renderPrint({
    uc_homOutput()
  })
  
  output$report <- downloadHandler(
    # For PDF output, change this to "report.pdf"
    filename = "report.html",
    content = function(file) {
      # Copy the report file to a temporary directory before processing it, in
      # case we don't have write permissions to the current working dir (which
      # can happen when deployed).
      tempReport <- file.path(tempdir(), "report.Rmd")
      file.copy("report.Rmd", tempReport, overwrite = TRUE)
      
      # Set up parameters to pass to Rmd document
      params <- list(modelSummary = uc_homOutput(), uc=values$uc)
      
      # Knit the document, passing in the `params` list, and eval it in a
      # child of the global environment (this isolates the code in the document
      # from the code in this app).
      rmarkdown::render(tempReport, output_file = file,
                        params = params,
                        envir = new.env(parent = globalenv())
      )
    }
  )
}

shinyApp(ui = ui, server = server)